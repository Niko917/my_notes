Потоками называются наименьшие независимые единицы выполнения, являющиеся частью процессов.

Современные системы позволяют разработчикам писать программы, поддерживающие множество потоков, работающих конкурентно в одном процессе.

При этом потоки также автоматически контролируются и и выполняются под управлением ядра операционной системы.

Каждый поток имеет свой контекст. 
В этот контекст входит:

- Идентефикатор потока (`Thread ID/TID`)
- Стек соответсвующего потока
- Stack pointer (`SP`)
- Счётчик команд (`Instruction pointer/IP`)
- Значения регистров общего назначения

Все потоки, выполняемые в рамках одного процесса, разделяют между собой всё виртуальное адресное пространство этого процесса.

---
## Thread execution model

Модель выполнения нескольких потоков во многом схожа с моделью выполнения нескольких процессов.

Каждый процесс начинается как один поток, называемый **основным потоком (main thread)**.

В какой-то момент времени основной поток создаёт еще один, *peer-поток* (peer thread) для выполнения некоторых задач параллельно.
С этого момента оба потока выполняются одновременно, исполняя различные части программы.

В какой-то момент управление может перейти от главного потока к peer-потоку с помощью механизма, называемого *переключением контекста*.

Произойти это может например в случае, когда основной поток выполняет медленный системный вызов (`read`/`sleep`) или когда его прерывает системный таймер.

Peer-поток выполняется какое-то время, после чего управление снова возвращается к основному потоку, и так далее.
![concurrent thread execution|550](https://github.com/user-attachments/assets/903c35ea-168c-43d4-8849-33312ba25935)

Как известно, процессы организованы в строгой иерархии, где каждый процесс может иметь родительский и дочерние процессы.

Однако в отличие от процессов, потоки не организованы в такой жёсткой иерархии. Все потоки одного процесса формируют `pool of peers`. Это означает, что любой поток может быть создан любым другим потоком, и они не зависят друг от друга и не образуют иерархию. В этом плане главный поток отличается от остальных только тем, что он всегда является первым запускаемым потоком в процессе.

Главное следствие модели `pool of peers` заключается в том, что любой поток может "убить" любой другой поток или ждать завершения любого другого потока. Это добавляет гибкости в управлении потоками, но также требует механизмов синхронизации, чтобы избежать проблем, связанных с одновременным доступом к ресурсам.

---
## Shared variables

Переменные могут быть представлены в виртуальной памяти двумя различными способами:

| Тип переменной                        | Описание                                                                                            | Пример                                                                                                              |
| ------------------------------------- | --------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| **Глобальные/статические переменные** | В момент выполнения существует только один экземпляр глобальной переменной, доступный всем потокам. | Если объявлена глобальная переменная `ptr`, все потоки ссылаются на один и тот же экземпляр `ptr`.                  |
| **Локальные переменные**              | Каждый поток использует свой собственный стек, на котором хранятся экземпляры локальных переменных. | Даже если несколько потоков исполняют одну и ту же функцию, у каждого потока будут свои копии локальных переменных. |

переменная называется **общей (Shared variable)**, только в том случае, если её экземпляр представлен более чем в одном потоке

---
## Race condition

Race condition - это ситуация, называемая "гонкой", в которой результат выполнения программы зависит от порядка или времени выполнения конкурирующих операций. То есть два или более потока одновременно обращаются к общему ресурсу и хотя бы один из них пытается изменить состояние этого ресурса.

