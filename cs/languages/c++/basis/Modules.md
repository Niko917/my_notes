Модули - это автономные блоки кода, которые могут экспортировать и импортировать объявления. Модули позволяют организовать код в логические блоки, упрощая его понимание, повторное использование и поддержку.

Данная функциональность призвана решить многие проблемы, связанные с традиционными заголовочными файлами.

Традиционные заголовочные файлы в C++ имеют ряд недостатков:

- **Зависимость от порядка включения:** Порядок включения заголовочных файлов может влиять на поведение программы, что приводит к ошибкам, которые трудно отладить.
    
- **Загрязнение глобального пространства имен:** Заголовочные файлы могут добавлять определения в глобальное пространство имен, что может привести к конфликтам имен.
    
- **Медленная компиляция:** Компиляция может быть медленной, особенно для больших проектов, из-за необходимости многократно компилировать один и тот же код.


Введение модулей в C++20 позволило решить эти проблемы, так как модули позволяют изолировать код от других модулей, предотвращая загрязнение глобального пространства имен и дублирование кода, а также ускоряют компиляцию, так как модули компилируются один раз и кэшируются, что уменьшает время компиляции и улучшает производительность.


В отличии от классических заголовочных файлов, модули компилируются отдельно, а результатом компиляции модуля является **Module Interface Unit** (MIU). Это бинарный файл, содержащий скомпилированный интерфейс модуля. 

При этом импорт модулей происходит также на этапе компиляции. Когда компилятор встречает директиву `import`, он использует уже скомпилированный модуль (MIU), что позволяет избежать повторной компиляции и уменьшить время компиляции.

На этапе линковки модули работают аналогично обычным объектным файлам. Линкер объединяет все модули и объектные файлы в единый исполняемый файл.


## Creating a Module

- **Создание модуля:** Модуль создается с помощью ключевого слова `export module`.

``` cpp  
// my_module.cpp
export module my_module;
    
export int add(int a, int b) {
    return a + b;
}
```

Объявления, которые должны быть доступны из других модулей, должны быть экспортированы с помощью ключевого слова `export`.


- **Импорт модуля:** Модуль импортируется с помощью ключевого слова `import`.

``` cpp
// main.cpp
import my_module;
    
int main() {
    int result = add(2, 3);
    return 0;
}
```

---
## Modules export blocks

С помощью **export block** можно экспортировать множество идентификаторов в качестве единой сущности:

``` cpp
// math_operations.cpp
export module math_operations;

export {
    int add(int a, int b) {
        return a + b;
    }

    int subtract(int a, int b) {
        return a - b;
    }

    int multiply(int a, int b) {
        return a * b;
    }

    int divide(int a, int b) {
        return a / b;
    }
}
```

Это позволяет управлять видимостью и улучшить читаемость кода.

---
## Module Transitive Dependencies

Транзитивные зависимости возникают, когда модуль `A` импортирует модуль `B`, а модуль `B` импортирует модуль `C`. В этом случае модуль `A` также получает доступ к объявлениям из модуля `C`, если модуль `B` экспортирует эти объявления.

Для того чтобы сделать зависимость транзитивной, необходимо использовать ключевое слово `export import`. Это позволяет модулю экспортировать объявления из другого модуля, что делает их доступными для всех модулей, которые импортируют данный модуль.


Рассмотрим пример, в котором у нас есть три модуля:
`module_a`, `module_b` и `module_c`. Мы хотим, чтобы модуль `module_a` имел доступ к объявлениям из `module_c` через `module_b`:

``` cpp
// module_c.cpp
export module module_c;

export int c_function() {
    return 42;
}

// module_b.cpp
export module module_b;

export import module_c;

export int b_function() {
    return c_function() + 10;
}

// module_a.cpp
export module module_a;

import module_b;

export int a_function() {
    return b_function() + 5;
}
```

---
## Submodules

В случае, если есть необходимость разбить большой модуль на несколько смысловых частей, то для этой цели есть **submodules**.

Подмодуль — это часть модуля, которая может содержать свои собственные объявления и определения. Подмодули позволяют организовать код в иерархическую структуру, где каждый подмодуль представляет собой отдельный блок функциональности.

``` cpp
// arithmetic.cpp
export module math_operations.arithmetic;

export int add(int a, int b) {
    return a + b;
}

export int subtract(int a, int b) {
    return a - b;
}


// geometry.cpp
export module math_operations.geometry;

export double area_of_circle(double radius) {
    return 3.14159 * radius * radius;
}

export double perimeter_of_circle(double radius) {
    return 2 * 3.14159 * radius;
}
```


Подмодули могут содержать свои собственные подмодули, что позволяет создавать иерархические структуры любой глубины.

``` cpp
// math_operations.arithmetic.basic.cpp
export module math_operations.arithmetic.basic;

export int add(int a, int b) {
    return a + b;
}

export int subtract(int a, int b) {
    return a - b;
}


// math_operations.arithmetic.cpp
export module math_operations.arithmetic;

export import math_operations.arithmetic.basic;
export import math_operations.arithmetic.advanced;
```

---


