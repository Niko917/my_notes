*[Ссылка](https://ru.cppreference.com/w/cpp/language/reference) - это псевдоним для уже существующего объекта в памяти.

Использование ссылок позволяет обращаться к переменным без их копирования и траты лишней памяти.*

---

## Why?

- Ссылки особенно полезны при передаче больших структур данных или классов в функции.

- При передаче объекта по ссылке функция работает с самим объектом, не копируя оригинальный объект (как это случается при передаче объекта по значению)

---

## properties

1. Ссылки не являются объектами.

2. Ссылка всегда является lvalue.

3. Ссылка должна быть инициализирована при объявлении.

5. Ссылка не может быть нулевой, то есть всегда связана с заимствованным объектом.

7. Ссылки неизменны => после инициализации ссылка не может быть переопределена для указания на другой объект

8. Так как ссылки не являются объектами, не существует массивов ссылок, указателей на ссылки, и ссылок на ссылки 

**С точки зрения реализации компилятора ссылка обычно реализуется в качестве указателя, который автоматически разыменовывается каждый раз при использовании этой ссылки.**

**Указатели предпочтительнее, когда требуется динамическое выделение памяти, манипулирование массивами, или когда нужна возможность изменить то, на что указывает переменная.**



рассмотрим пример для окончательного понимания ссылок.

``` cpp
int x = 5;
int& y = x;
	y++; // it's literally x++
```

``` cpp
int x = 5;
int& y = x;

int z = 7;
y = z; // x = z
```

``` cpp
int x = 5;
int& y = x;

int& t = y; // t referrs on x
```

``` cpp
int x = 10;
int& y = x;

sizeof(y); // returnvalue - size of x (4 bytes)
```

---
# dangling reference

битая ссылка - это ссылка,которая живет дольше, чем объект на который она ссылается


Пример 1. Ссылка на локальную переменную, вышедшую из области видимости.

``` cpp
int& getReference() {
    int local = 42;
    return local; // Возвращаем ссылку на локальную переменную
}

int& ref = getReference(); // ref теперь "битая ссылка"
```

В этом примере функция возвращает ссылку на локальную переменную local. 

Как только функция завершает своё выполнение, переменная local выходит из области видимости, и её память освобождается.

Однако ссылка ref всё ещё "указывает" на место в памяти, где эта переменная ранее находилась, что делает её битой.

---
Пример 2. ссылка на освобождённую динамическую память.

``` cpp
int* ptr = new int(42); 
int& ref = *ptr; 
delete ptr; 

// now `ref` is a dangling reference because memory was deallocated
```

---
# [Advanced](https://habr.com/ru/articles/646005/)
