[анонимная функция](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%BE%D0%BD%D0%B8%D0%BC%D0%BD%D0%B0%D1%8F_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F) (lambda function) - это функция, которая не привязана к идентификатору и определяется в месте вызова


$\triangle$ closure (замыкание) - это отдельный тип в языке Rust, представляющий из себя анонимные функции, которые *захватывают объекты из окружающего контекста.*

`closure = |captures| { body of closure }`

---
## Capturing

Захват - это механизм, который позволяет замыканию использовать объекты из окружающей среды.

### Implicit capturing

- по умолчанию замыкания захватывают объекты неявно.
	- замыкание будет захватывать объекты по неизменяемой ссылке, если это возможно
		- в случае необходимости замыкание может переходить к более "сильным" способам захвата (по изменяемой ссылке или по значению).

пример неявного захвата:

``` Rust
let x = 42;
let closure = || println!("{}", x);
closure(); // output: 42
```

В этом примере замыкание `closure` захватывает переменную `x` по неизменяемой ссылке (`&T`), так как для вывода значения `x` достаточно иметь доступ только для чтения.

 
### `move` [keyword](https://doc.rust-lang.org/std/keyword.move.html)

ключевое слово `move` используется в случае, когда необходимо явно указать, что замыкание должно захватывать объекты перемещением.

Также ключевое слово `move` часто используется для возможности замыканию пережить захваченные объекты. 

(например, если, замыкание возвращается или используется для создания нового потока)


- при перемещении замыкание получает владение над объектами и они перемещаются внутрь замыкания. 

``` Rust
let data = vec![1, 2, 3];
let closure = move || println!("captured {data:?} by value");

// data is no longer available, it is owned by the closure
```


- также `move` часто используется при работе с потоками

``` Rust
let data = vec![1, 2, 3];

std::thread::spawn(move || {
    println!("captured {data:?} by value")
}).join().unwrap();

// data was moved to the spawned thread, so we cannot use it here
```


---
## [Types of capturing](https://stackoverflow.com/a/45935645)

В Rust существует три типа замыканий, которые различаются по способу захвата объектов и определяются с помощью трейтов `Fn`, `FnMut`, `FnOnce`:

- `FnOnce` - это базовый closure trait.
	- позволяет вызывать замыкание только один раз.
	- автоматически реализуется замыканиями, которые перемещают захваченные объекты.
	- `FnOnce` является супертрейтом для `Fn` и `FnMut`
		- любой экземпляр `Fn` и `FnMut` может быть использован там, где ожидается экземпляр трейта `FnOnce`.

- `FnMut` - это подтрейт (расширение) для `FnOnce`.
	- предоставляет возможность множественного вызова для замыканий.
	- предоставляет возможность замыканию изменять захваченные объекты.

- `Fn` - это подтрейт (расширение) для `FnMut`.
	- предоставляет возможность множественного вызова для замыканий.
	- ограничивает замыкание от изменения захваченных объектов.

---
### [Subtrait relationship](https://cheats.rs/#closures-in-apis)

В языке Rust между closure traits, определено отношение:
$$
FnOnce \leq FnMut \leq Fn
$$

---

## [Memory layout ](https://www.youtube.com/watch?v=rDoqT-a6UFg&t=2077s)



<img src=https://github.com/user-attachments/assets/ed45f3eb-3ef4-4fd5-ac04-f31ee1b13806 width=500>


замыкания внутренне устроены как отдельные структуры, реализующие closure traits

``` Rust
fn main() {
    let x = 42;
    let closure = move |y: i32| x + y;
    println!("{}", closure(10));
}
```

``` Rust
// de-sugaring
struct Closure {
    x: i32,
}

impl FnOnce<(i32,)> for Closure {
    type Output = i32;
    fn call_once(self, args: (i32,)) -> i32 {
        self.x + args.0
    }
}
```

В этом примере `Closure` — это анонимный тип, сгенерированный компилятором, который включает поле для захваченной переменной `x`. 

Реализация трейта `FnOnce` обеспечивает вызов замыкания.

