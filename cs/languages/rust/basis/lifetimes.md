[lifetimes](https://www.youtube.com/watch?v=rAl-9HwD858) - это механизм в языке Rust, который гарантирует, что ссылки на объекты остаются действительными в течении всего времени их использования.

---

## [basis.](https://cheats.rs/#memory-lifetimes)

lifetime (время жизни) - это область видимости (namespace), в которой ссылка действительна.

В Rust время жизни обозначается с помощью аннотаций, которые начинаются с апострофа `'`.
- `'a` - типичное обозначение lifetime


***Основная цель времён жизни в Rust - предотвращение ситуаций, в которых существуют ссылки на объекты, время жизни которых закончилось (dangling references)***

- достигается это за счет явного указания срока жизни ссылки, для которой время жизни может быть определено по разному компилятором.

- аннотации lifetimes помогают [[borrow checker]]'у проверить выполнение правил заимствования в указанной части программы


``` Rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } 
    else {
        y
    }
}

fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
```

В этом примере функция `longest` принимает две строковые ссылки и возвращает ссылку на самую длинную строку. 

Аннотация `'a` указывает, что возвращаемая ссылка будет действительна, пока действительны входные ссылки.


---

## Lifetime Elision

Lifetime Elision — это механизм, который позволяет компилятору Rust автоматически выводить lifetimes для ссылок в функциях и методах, что упрощает написание кода и уменьшает количество необходимой аннотации lifetimes. 

Этот механизм основан на наборе предопределенных правил, которые компилятор использует для вывода lifetimes, если они не указаны явно.

***Правила Lifetime Elision***

- **Каждая ссылка в списке параметров функции получает свой собственный lifetime**. 
    
- **Если есть ровно одна входная ссылка с lifetime**, то этот lifetime присваивается всем выходным ссылкам.
    
- **Если есть несколько входных ссылок с lifetime, но при этом одна из них является ссылкой на `self` (для методов), то lifetime `self` присваивается всем выходным ссылкам.**

- **в случае, если входных ссылок несколько, то выходная ссылка должна иметь lifetime больший, чем у всех входных ссылок.**

---

## Lifetime Bounds

Lifetime bounds - это механизм в языке Rust, который позволяет ограничивать lifetimes для гарантии того, что ссылки останутся действительными на протяжении необходимого времени.

### Lifetime subtyping

`('a: 'b')` -> Lifetime subtyping используется для указания, что одно время жизни больше или равно другому. 

- Это означает, что если `'a` живет дольше или так же долго, как `'b`, то `'a` может быть использовано везде, где требуется `'b`.

``` Rust
struct DoubleRef<'a, 'b: 'a, T> {
	r: &'a T,
	s: &'b T,
}
```

В этом примере `'b: 'a` означает, что время жизни `'b` должно быть не короче, чем `'a`. 

***Это гарантирует, что ссылка `s` будет действительна, пока существует ссылка `r`.***


### Higher-rank Trait bounds, "(for<'a>)"

HRTBs - это способ явного указания, что данный Trait должен быть реализован для любого возможного времени жизни, которое связано с типами, реализующими данный Trait.


``` Rust
trait MyTrait<'a> {
    fn do_something(&self, x: &'a i32);
}

fn bar<T>(t: T)
where
    T: for<'a> MyTrait<'a>,
{
    let x = 10;
    t.do_something(&x);
}
```

В этом примере `for<'a> MyTrait<'a>` означает, что какой бы lifetime мы не взяли, тип `T` должен реализовывать `MyTrait`

=> $\forall 'a \quad |$ $T$ must impl $MyTrait<'a>$

---
## 'static lifetime

ключевое слово с аннотацией `'static` явно указывает, что ссылка имеет статическое время жизни 
- (действительна на  протяжении всего времени жизни программы)

``` Rust
let s: &'static str = "I have a static lifetime.";
```


***при этом важно различать `&'static T` и `T: 'static`.***

- `& 'static T` - это статическая ссылка на тип `T`, которая ***живёт на протяжении времени жизни всей программы.***

	- Это возможно только в том случае, если сам `T` является неизменяемым и не перемещается _после создания ссылки_.


- `T: 'static` может быть динамически создан в процессе runtime, безопасно и беспрепятственно изменён и удалён, а также может существовать в течение произвольных промежутков времени

	- `T: 'static` — это некий `T`, который можно хранить безопасно бесконечно долго, в том числе вплоть до конца работы программы.
	
	- `T: 'static` включает в себя все `&'static T`, однако оно также включает в себя все владеющие типы, такие как `String`, `Vec` и т. д.

	- `T: 'static` ***не обязан существовать на протяжении всего времени жизни программы***, а может иметь время жизни произвольной продолжительности.
	
	- Владелец некоторых данных является гарантом того, что данные никогда не будут инвалидированы, пока владелец их удерживает, следовательно, владелец может безопасно хранить данные сколь угодно долго, в том числе вплоть до конца работы программы. 
	
	- `T: 'static` должно читаться, как _«`T` ограничен временем жизни `'static`»_


---

