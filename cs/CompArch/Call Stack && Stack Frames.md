Стек вызовов - это динамическая структура данных, поддерживаемая операционной системой для отслеживания вызовов функций и контроля жизненного цикла процесса во время его выполнения.

Стек вызовов состоит из стековых фреймов, каждый из которых соответствует определённой функции или процедуре этого процесса.

Стек вызовов содержится "внутри" сегмента стека.

Также в работе стека вызовов задействованы некоторые регистры:

- Регистр `%ebp` хранит адрес текущего стекового фрейма 
  (`Frame Pointer \ Base Pointer`).

- Регистр `%esp` хранит адрес текущей "вершины" стека вызовов.

(`%rbp` и `%rsp` в случае `x86_64`)

---
## Stack frame

Каждый фрейм в стеке вызовов представляет собой диапазон виртуальных адресов, представляющих информацию и данные соответсвующей функции.

Основные состовляющие каждого фрейма:

- Адрес возврата
- Аргументы функции
- Локальные переменные
- Сохранённые значения регистров
![Stack frame structure|400](https://github.com/user-attachments/assets/c9013848-6cc1-4f2c-bd23-c8f5cf79999e)

В архитектуре `x86` аргументы функции и локальные переменные этой функции распологаются относительно базового адреса данного фрейма.


Что происходит при вызове функции? Рассмотрим на примере:

``` C++
#include <iostream>
int sum(int a, int b) {
    return a + b;
}

int main() {
    int x = 5;
    int y = 10;
    int result = sum(x, y);
    std::cout << "Result: " << result << std::endl;
    return 0;
}
```

Вот ассемблерное представление вызова функции `result` из функции `main`:

``` assembly
sum(int, int):

	push rbp
	mov rbp,rsp
	mov DWORD PTR [rbp-0x4],edi
	mov DWORD PTR [rbp-0x8],esi
	
	mov eax,DWORD PTR [rbp-0x4]
	add eax,DWORD PTR [rbp-0x8]
	pop rbp
	ret
```

1. `push rbp` - сохранение адреса фрейма функции `main` в стеке вызова. 
	- Данный адрес будет являться адресом возврата для фрейма функции `result`.

2. `mov rbp, rsp` - установка значения регистра `rbp` на текущее значение регистра `rsp`. Таким образом, прошлая "вершина" стека становится адресом фрейма функции `result`

3. `mov DWORD PTR [rbp-0x4], edi` - копирование значения регистра `edi`, которое является первым аргументом функции `result` в стек вызовов по адресу `[rbp-0x4]`
	- `edi` (Extended Destination Index) - это регистр общего назначения, используется для передачи первого аргумента функции

5. `mov DWORD PTR [rbp-0x8], esi` - копирование значение регистра `esi`, которое является вторым аргументом функции `result` в стек вызовов по адресу `[rbp-0x8]`
	- `esi` (Extended Source Index) - это регистр общего назначения, используется для передачи второго аргумента функции

6. `mov eax, DWORD PTR [rbp-0x4]` - загрузка значения первого аргумента из стека вызовов в регистр `eax`
	- `eax \ rax` - это регистр общего назначения, используется для различных арифметических операций и в качестве аккумулятора

7. `add eax, DWORD PTR [rbp-0x8]` - Сложение значения второго аргумента со значением регистра `eax` (значением первого аргумента). 
	- Результат сохраняется в регистре `eax`

8. `pop rbp` - значение регистра `rbp` обновляется адресом предыдущего фрейма

9. `ret` - извлечение адреса возврата из стека вызовов и передача управления по этому адресу

---
### Register usage convensions

В архитектуре `x86` набор регистров процессора является общим ресурсом для всех доступных процедур / функций процесса. И хотя в любой момент времени может быть активна только одна процедура, важно обеспечить гарантию, что при вызове вызывающей процедуры, вызываемая процедура не перезапишет значения регистров, которая вызывающая процедура планирует использовать позже.

Поэтому в архитектуре `x86-64` принята единая система соглашений по использованию регистров.

В архитектуре x86-64 есть 16 регистров общего назначения:

- `%rax`, `%rbx`, `%rcx`, `%rdx`
	- Регистры общего назначения.    
- `%rsi`, `%rdi`
	- Регистры для работы с данными (source и destination).
- `%rbp`
	- Содержит адрес текущего фрейма стека вызовов.
- `%rsp`
	- Содержит адрес вершины стека вызовов.
- `%r8`, `%r9`, `%r10`, `%r11`, `%r12`, `%r13`, `%r14`, `%r15`
	- Дополнительные регистры общего назначения.

Они делятся на несколько групп:

- **Caller-save регистры** — это регистры, значения которых могут быть изменены (перезаписаны) вызываемой процедурой (callee) без специального сохранения их значений. Если вызывающая процедура (caller) хочет сохранить значения этих регистров в стеке вызовов, она должна сделать это сама перед вызовом другой процедуры.

	- **Примеры:** `%rax`, `%rcx`, `%rdx`, `%rsi`, `%rdi`, `%r8`, `%r9`, `%r10`, `%r11`.


- **Callee-save регистры** — это регистры, значения которых должны быть сохранены в стеке вызовов вызываемой процедурой перед их перезаписью и восстановлены перед возвратом. Это делается для того, чтобы вызывающая процедура (caller) могла использовать эти регистры после возврата из вызываемой процедуры, не опасаясь, что их значения будут изменены.

	- **Примеры:** `%rbx`, `%rbp`, `%r12`, `%r13`, `%r14`, `%r15`.

---
## Kernel stack

Стек ядра - это сегмент виртуального адресного пространства процесса. Он является частью Kernel virtual memory.


В архитектуре `x86-64` стек ядра имеет фиксированный размер, который обычно составляет `2 * PAGE_SIZE` = 8КБ. Таким образом, он защищён от переполнения.


Стек ядра необходим для хранения локальных переменных, адресов возврата и других данных, необходимых для выполнения кода ядра.


При создании процесса операционной системой создаётся новый стек ядра. Каждый поток в процессе также имеет "собственный" стек ядра, так как может выполнять системные вызовы и обрабатывать прерывания независимо от других потоков.


При выполнении системного вызова процессор переключается в режим ядра, адрес возврата и контекст процесса или потока сохраняются в стеке вызовов ядра, чтобы обеспечить корректное завершение процесса.

Контекстом процесса называется совокупность всех данных и состояний, необходимых для выполнения этого процесса.

---
## Links

1. https://userpages.cs.umbc.edu/chang/cs313.s02/stack.shtml
