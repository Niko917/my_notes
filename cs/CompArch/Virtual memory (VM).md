Виртуальная память - это абстракция над физической памятью, которая определяет взаимодействие различных адресных пространств, предоставляя каждому процессу единообразное и приватное адресное пространство.


VM предоставляет 3 основные возможности:

- **Эффективное использование физической памяти**
	- VM рассматривает RAM в качестве кэша для адресного пространства, хранящегося на диске.
		- Только "активные" области данных хранятся в физической памяти, а остальные находятся на диске.

-  **Упрощение управления памятью**
	- VM упрощает управление памятью, предоставляя каждому ресурсу уникальное единое адресное пространство.
		- каждый процесс имеет свою линейную последовательность адресов, разбитую на сегменты.

- **Защита адресного пространства**
	- VM обеспечивает защиту адресного пространства каждого процесса от повреждении другими процессами.

---

**Особенности работы вируальной памяти**


- В процессе выполнения инструкции, которая требует достапу к памяти, CPU обращается к RAM, генерируя виртуальный адрес (VA), который затем преобразуется в соответсвующий физический адрес.
	- Задача преобразования адреса называется *трансляцией адреса* (adress translation).

- в CPU находится специальный юнит, называемый **блоком управления памятью** (memory managment unit, MMU), который выполняет трансляцию виртуальных адресов, используя таблицы страниц (page tables), которые расположены в RAM и поддерживаются операционной системой.
	- MMU обращается к таблице страниц (page table), которая хранится в RAM.
		- Таблица страниц содержит информацию о том, как виртуальные адреса отображаются на физические. 
			- Каждый процесс имеет свою собственную таблицу страниц.



<img src="https://github.com/user-attachments/assets/5cc2fed5-2290-4983-921a-af74d47ddbaf" alt="Virtual_adress_translation_1" width="700" height="400">

---
## Adress spaces


*Адресное пространство* - это упорядоченное множество адресов
$$\large {\{0, 1, 2, ... \}}$$

если цифры в адресах  образуют последовательность, то такое адресное пространство называется *линейным*.

В системе с поддержкой виртуальной памяти, CPU генерирует виртуальный адрес из адресного пространства из $\large N = 2^n$ адресов, называемого *виртуальным адресным пространством*:

$$\large\{0, 1, 2 ,..., N-1\}$$

размер адреса определяется числом бит, необходимым для представления наибольшего числа.

это число бит определяется архитектурой процессора, а именно разрядностью регистров процессора.

- В контексте архитектуры `x86-64` адресное пространство может быть представлено как набор всех возможных 64-битных адресов.

концепция адресного пространства позволяет различать данные и их атрибуты, а также использовать множество независимых адресов для одного и того же объекта данных.

<img src="https://github.com/user-attachments/assets/ffc21a7f-0a3e-4277-b03d-8e5e0fa43e1d" alt="using_ram_as_cache_1" width="700">


Это и есть основная идея виртуальной памяти: каждый байт данных в RAM имеет виртуальный адрес из виртуального адресного пространства, а также реальный адрес из физического адресного пространства (RAM). 

---
## Virtual pages

Виртуальное адресное пространство разбивается на блоки фиксированного размера, называемые  виртуальными страницами (VPs)

Размер каждой виртуальной страницы - $\large{2^p}$ байт.

Аналогично, физическая память (RAM) также разбивается на блоки фиксированного размера, называемые физическими страницами (PPs) или страничными фреймами. 

Размер физических страниц также составляет $\large2^p$ байт, что совпадает с размером виртуальных страниц.


В любой момент времени набор виртуальных страниц может быть распределён на три разные непересекающиеся группы:

- ***Unallocated***
	- Это страницы, которые еще не были созданы или выделены системой управления виртуальной памятью. 
		- Поскольку они не были выделены, с ними не связаны никакие данные, и они не занимают места на диске.
- ***Cached***
	- Это страницы, которые были выделены и в данный момент находятся в RAM.
- ***Uncached***
	- Это страницы, которые были выделены, но в данный момент не находятся в RAM. 
		- Они могут находиться на диске и будут загружены в RAM, если к ним потребуется доступ.


Из-за большого штрафа за промах (данные не находятся в кэше и нужно обращаться к диску) виртуальные страницы, как правило, имеют большой размер, обычно от 4KB до 2MB. 

Это делается для того, чтобы уменьшить количество обращений к диску.

---
## Page tables

Page table - это структура данных, хранящаяся в RAM, которая сопоставляет виртуальные страницы с физическими страницами (mapping).

Как было указано выше, любая страница может находится в одном из трёх состояний, которые определяют её расположение.

Когда система работает с виртуальной памятью, она использует таблицы страниц для контроля состояния страниц

Если виртуальная страница находится в RAM, это означает, что она уже была загружена из более медленного дискового хранилища в RAM для ускорения доступа к данным.


<img src="https://github.com/user-attachments/assets/af31d74a-db3c-4b4f-a539-2e5d353c3bd9" alt="page_table" width="700">


таким образом, page table это просто массив из page table enries (PTEs).

---
## Page faults

Механизм обработки page fault в виртуальной памяти включает несколько ключевых шагов, которые происходят, когда процессор пытается получить доступ к виртуальной странице, которая не кэширована в оперативной памяти.

| Этап | Описание процесса                                                                                                                       |
| ---- | --------------------------------------------------------------------------------------------------------------------------------------- |
| 1    | Процессор выполняет инструкцию, которая требует доступа к данным на определенной виртуальной странице.                                  |
| 2    | MMU (Memory Management Unit) обращается к таблице страниц, чтобы определить, где физически находится виртуальная страница.              |
| 3    | Если виртуальная страница не кэширована в RAM, происходит page fault.                                                                   |
| 4    | MMU генерирует исключение page fault, которое передается операционной системе.                                                          |
| 5    | Операционная система переходит к выполнению кода обработчика исключения, который специализирован для обработки page fault.              |
| 6    | Обработчик исключения выбирает физическую страницу (страницу-жертву), которая будет заменена.                                           |
| 7    | Если страница-жертва была изменена, она должна быть скопирована обратно на диск, чтобы сохранить изменения.                             |
| 8    | Операционная система обновляет запись таблицы страниц для страницы-жертвы, чтобы отразить, что она больше не находится в RAM.           |
| 9    | Операционная система загружает нужную виртуальную страницу с диска в физическую страницу, освобожденную на предыдущем шаге.             |
| 10   | Запись таблицы страниц для новой виртуальной страницы обновляется, чтобы указать, что она теперь находится в RAM.                       |
| 11   | Обработчик исключения завершает свою работу и возвращает управление, перезапуская инструкцию, которая вызвала page fault.               |
| 12   | Теперь, когда виртуальная страница кэширована в RAM, MMU успешно обрабатывает запрос, и процессор получает доступ к необходимым данным. |


Сам механизм обмена страниц называется **paging**

При этом все современные системы используют стратегию **demand paging**, которая заключается в том, что страница загружается в RAM только в случае page fault.

это позволяет минимизировать загрузку страниц, которые могут никогда не понадобится для выполнения процесса.

---
## Components of virtual and physical adresses

### Virtual adress

- **Индекс страницы (VPN (Virtual page number))** 
	- Это часть адреса, которая используется для поиска соответствующей записи в таблице страниц (PTE).
		
- **Смещение внутри страницы (Virtual Page Offset (bytes))** 
	- Это часть адреса, которая указывает на конкретное место внутри страницы.


### Physical adress
	
- **PPO (physical page offset (bytes))** 
	- это часть физического адреса, которая определяет смещение в байтах, относительно начала страницы и указывает на конкретное место внутри физической страницы
	
- **PPN (Physical page number)**
	- это часть физического адреса, которая указывает на номер физической страницы в памяти.

---
## Adress translation

**adress translation** - это процесс преобразования виртуального адреса в физический.

Формально, данный процесс является отображением из N-мерного адрессного виртуального пространства в M-мерное физическое адресное пространство.

$$\large{MAP: VAS \rightarrow PAS \space \cup \space \not \emptyset}$$

Система отображения адресов (MAP) может быть записана следующим образом:
$$
\text{MAP}(A) =
\begin{cases}
A' & \text{если данные по виртуальному адресу A присутствуют по адресу A' в PAS} \\
\large \emptyset & \text{если данные по виртуальному адресу A отсутствуют в физической памяти}
\end{cases}
$$

$\large A'$ - это физический адрес, принадлежащий физическому адресному пространству (PAS)


---

**Итак, опишем сам процесс трансляции адреса:**

- CPU генерирует виртуальный адрес и передаёт его на модуль MMU

- MMU определяет PTE адресс и запрашивает его из RAM

- RAM возвращает необходимый PTE адресс назад в MMU

- MMU проверяет бит валидности в таблице страниц
	- Если бит валидности этого адреса равен 1, то MMU определяет физический адрес и отправляет его в RAM
	- Если бит валидности равен 0, то MMU вызывает исключение (page fault), которое передаёт контроль обработчику ошибок, который является частью ядра OS
	- Обработчик ошибок определяет 'victim page' в RAM и отправляет эту страницу на на диск
	- После освобождения места, обработчик загружает новую страницу с диска в физическую память и обновляет соответствующую запись в таблице страниц (PTE), чтобы отразить новое местоположение данных.
	- контроль над процессом возвращается в CPU с инструкцией повторной трансляции и процесс трансляции повторяется
    
- Данные, на которые указывает физический адрес, возвращаются процессору для дальнейшей обработки.


<img src="https://github.com/user-attachments/assets/5f570fd0-5f57-4fb3-bda3-a1b40db71119" alt="adress_translation_1" width="800">


---
## Translation lookaside buffer

Поскольку почти каждое обращение к странице в виртуальной памяти должно быть разрешено в соответствующий адрес в физической памяти, производительность таблиц страниц очень важна.

Для облегчения этой задачи в большинстве процессоров реализован ***TLB (translation lookaside buffer)***, который выступает в роли аппаратного кэша виртуально-физических отображений. 


TLB хранит недавно использованные пары виртуальных и физических адресов (VPN и PPN), что позволяет быстро находить соответствие без дополнительных обращений к основной таблице страниц.

TLB состоит из нескольких полей, разбитых на строки.


***в случае использования TLB, трансляция адреса происходит следующим образом:***

- CPU генерирует виртуальный адрес
- MMU сначала проверяет TLB на наличие соответствующей записи. 
	- Если запись найдена (TLB hit), MMU использует физический адрес из TLB.
- MMU транслирует виртуальный адрес в физический и отправляет его в RAM
- RAM возвращает данные из этого адреса процессору



<img src="https://github.com/user-attachments/assets/c8bbe7ed-cb4b-4a4c-b44f-d808d229240a" alt="TLB adress translation 1" width="700">


---
## Multi-level Page tables

До этого момента мы предполагали, что система использует одноуровневую таблицу для преобразования адресов.

Но если бы у нас было 32-разрядное адресное пространство, страницы размером 4KB и 4-байтовый PTE, то нам постоянно требовалась бы таблица страниц размером 4MB в памяти, даже если процесс ссылается только на небольшой фрагмент виртуального адресного пространства.
Проблема усугубляется в системах с 64-разрядными адресными пространствами.

Распространенным подходом к сжатию таблицы страниц является использование **иерархии таблиц страниц**.

- Обычно используется несколько уровней таблиц страниц.

	- Каждый уровень таблицы содержит указатели на следующий уровень или на физические страницы

- Начиная с корневой таблицы страниц (Page Directory, PD), MMU использует старшие биты виртуального адреса для поиска записи в текущем уровне таблицы.
    
	- Найденная запись указывает на следующий уровень таблицы.
    
	- Процесс повторяется до тех пор, пока не будет найдена запись, указывающая на физическую страницу.
    
	- Cмещение внутри адреса (VPO) добавляется к базовому адресу физической страницы для получения окончательного физического адреса.


Для полноценного понимания работы иерархии таблиц, **рассмотрим k-уровневую систему**

Виртуальный адрес делится на **k** виртуальных номеров (VPN) и на смещение VPO.

- Каждый **i-й** VPN $i \leq i \leq k$ является индексом в таблице страниц на уровне **i**.

- Каждая запись (PTE) в таблице на уровне **j** $\large (1 \leq j \leq k − 1)$ указывает на базовый адрес таблицы на уровне $\boldsymbol{\large j + 1}$.

- Каждая запись в таблице на уровне **k** содержит либо физический номер страницы (PPN), либо адрес дискового блока.




<img src="https://github.com/user-attachments/assets/14b67d62-f09e-4b2d-9fe9-2a95779ee634" alt="page_tables_hierarchy" width="700">


---
## PTEs


рассмотрим формат записей в таблицах страниц (PTEs)


<img src="https://github.com/user-attachments/assets/ed34bb4f-698c-46a4-98a3-759a7a540455" alt="PTE_1" width="700">


| Поле                               | Описание                                                                                                                                                                                                                                                                             |
| ---------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **P (Present Bit)**                | Указывает, находится ли дочерняя таблица в физической памяти (1) или нет (0).                                                                                                                                                                                                        |
| **R/W (Read (0) / Write Bit (1))** | Определяет доступ (только чтение / чтение и запись).                                                                                                                                                                                                                                 |
| **U/S (User / Supervisor Bit)**    | Определяет категорию доступа (режим ядра / пользовательский режим).                                                                                                                                                                                                                  |
| **WT (Write-Through Bit)**         | Определяет политику кеширования для дочерней таблицы страниц (write-back (0) / write-through (1)).                                                                                                                                                                                   |
| **CD (Cache Disable Bit)**         | Определяет, включено или отключено кеширование для дочерней таблицы страниц.                                                                                                                                                                                                         |
| **A (Accessed Bit)**               | Устанавливается MMU при доступе к дочерней таблице и указывает, была ли дочерняя таблица страниц использована для чтения или записи.  Ядро может использовать этот бит для реализации своего алгоритма перемещения страниц между адресными пространствами.                           |
| **PS (Page Size Bit)**             | Определяет размер физической страницы. Этот бит определён только для записей 1 уровня в иерархии.                                                                                                                                                                                    |
| **Base addr (PPN)**                | Содержит 40 наиболее значимых бит физического базового адреса дочерней таблицы страниц. Указывает на начало дочерней таблицы.                                                                                                                                                        |
| **XD (eXecute Disable Bit)**       | Предназначен для предотвращения выполнения кода из областей памяти, которые предназначены для хранения данных. Когда бит **XD** установлен в 1, он помечает страницы памяти как неисполняемые, что приводит к генерации исключения при попытке выполнить инструкции из этих страниц. |


на последнем уровне формат записей будет следующий:


<img src="https://github.com/user-attachments/assets/bd3988c9-2cab-4e37-ab0e-97e1531cce5e" alt="pte_layout" width="700">


он практически идентичен формату записей на первых уровнях, за исключением того, что на поледнем уровне `PPN` является базовым адресом искомой физической страницы, а бит `PS` зануляется, так его актуальность ограничена первым уровнем таблиц.
