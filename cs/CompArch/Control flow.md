
С момента начала работы процессора и до его выключения, счётчик команд последовательно принимает значения $a_{0}, \ldots a_{n-1}$, где каждое значение $a_{k}$ представляет собой адрес соответствующей команды $I_{k}$.

Переход от одного адреса команды к другому называется **передачей управления (control tranfer)**. 

Последовательность таких передач управления называется **потоком управления** (control flow).

Самый простой вид потока управления - это непрерывная плавная последовательность передач управления, где каждая команда $I_{k}$ и $I_{k+1}$ расположены в памяти последовательно.

Резкие изменения в потоке управления происходят, в случае, если адрес $I_{k+1}$ команды не является смежным для команды $I_{k}$. 

Обычно резкие изменения этого плавного потока управления вызваны определёнными инструкциями, а именно: прыжками (jumps), вызовами (calls) и возвратами (returns). 


Но системе также нужно иметь возможность реагировать на изменение состояния системы, которые не фиксируются внутренними данными процесса и не обязательно связаны с выполнением этого процесса. Например, родительские процессы, создающие дочерние процессы, должны быть уведомлены о завершении своих дочерних процессов.

Поэтому современные системы реагируют на эти ситуации, производя резкие изменения в потоке управления. Эти резкие изменения называются ***Исключительным потоком управления (Exceptional control flow / ECF)***. ECF происходит на всех уровнях компьютерых систем.

Например, на уровне ядра операционной системы ядро передаёт управление от одного пользовательского процесса к другому, используя механизм переключения контекста.

Итак, исключительный поток управления - это механизм, с помощью которого процессор может изменять поток выполнения команд в ответ на внешние события или исключенительные ситуациии.

---
## Exceptions

**Исключение** - это резкое изменение потока управления в результате изменения состояния процессора.

Исключения (Exceptions) являются частью исключительного потока управления (ECF). Частично они реализуются аппаратной частью системы (hardware) и частично операционной системой.


Пусть процессор выполняет какую-то инструкцию $I_{curr}$, когда происходит изменение его состояния. Изменение состояния процессора может быть закодировано в виде различных битов и сигналов внутри процессора. Это изменение состояния называется **событием (event)**.


*Событие* может быть связано напрямую с выполнением текущей инструкцией (например в случае virtual memory page fault, арифметического переполнения, попытки деления на ноль). Но также может и не быть связан с выполнением текущей инструкции (срабатывание системного таймера, завершение процесса ввода-вывода).


В любом случае, в момент, когда процессор определяет, что *событие* произошло, он вызывает исключение. То есть нормальное исполнение процесса прерывается и процессор переходит к выполению специальной процедуры. 

Для этого процессор выполняет команду `jump`, обращаясь к **обработчику исключений** через специальную **таблицу исключений**. Обработчик исключений является частью операционной системы.

Таким образом, при возникновении исключения процессор передаёт управление соответсвующему обработчику в ядре.

![anatomy of an exception|450](https://github.com/user-attachments/assets/79750180-25e6-4a12-a96b-44eb699335a1)

После завершения работы обработчика исключений, происходит одно из трёх действий, в зависимости от типа события, вызвавшего исключение:

- Обработчик возвращает управление текущей интсрукцией $I_{curr}$, инструкции, которая выполнялась в момент происшествия *события*. Следовательно, после обработки исключения процесс продолжит выполнение с той инструкции, на которой появилось исключение.

- Обработчик возвращает управление следующей инструкции $I_{next}​$, которая должна была быть выполнена, если бы исключение не произошло.

- Обработчик завершает прерванный процесс. После этого управление к нему уже не вернётся.


### Exception handling

Каждый тип возможного исключения в системе получает уникальный неотрицательный целочесленный *идентификатор исключения*.

Какие-то идентификаторы назначаются проектировщиками процессора, а какие-то проектировщиками ядра операционной системы.

![exception table|400](https://github.com/user-attachments/assets/53774888-f1b2-4997-aa4d-f3d8b3b7e072)


Во время загрузки системы, ядро операционной системы выделяет и инициализирует таблицу исключений так, что что запись $k$ в этой таблице содержит адрес обработчика для исключения $k$.

Во время выполнения, процессор определяет, что произошло *событие*, и определяет соответсвующий номер исключения $k$. Затем он выполнет косвенный вызов процедуры через таблицу исключений к соответсвующему обработчику. Номер исключения в таблице исключений, начальный адрес которой содержится в специальном регистре процессора, называемым **базовым регистром таблицы исключений** (exception table base register)


Вызов исключения похож на вызов обычной процедуры или функциию но с некотороми отличиями:

- Как и при вызове процедур, процессор помещает адрес возврата в стек вызовов перед переходом к обработчику исключений.

- В зависимости от типа *события*, адрес возврата может быть либо адресом текущей инструкции, либо адресом следующей инструкции

- В стек вызовов также помещается дополнительное процессорной состояние, которое необходимо для перезапуска прерванного процесса

- Если управление передаётся от пользовательского процесса или потока ядру, то всё процессорное состояние помещаются в сегмент стека ядра.


---
## Classes of Exceptions

Исключения могут быть поделены на 4 основные класса:

- Прерывания (interrupts)
- Ловушки (traps)
- Сбои (faults)
- Аварии (aborts)

разберём каждый из этих видов исключений:

| **Класс**  | **Причина**                                                                      | **Синхронность/Асинхронность** | **Поведение при возврате**                                                  |
| ---------- | -------------------------------------------------------------------------------- | ------------------------------ | --------------------------------------------------------------------------- |
| Interrupts | Сигнал от устройства ввода-вывода                                                | Асинхронное                    | Процессор возвращается к выполнению следующей инструкции.                   |
| Traps      | Выполнение специальной инструкции, такой как системный вызов или точка останова. | Синхронное                     | Процессор возвращается к следующей инструкции после вызова.                 |
| Faults     | Ошибка, которая может быть исправлена. (например, ошибка страницы)               | Синхронное                     | Процессор повторяет инструкцию, вызвавшую ошибку, если она была исправлена. |
| Aborts     | Неисправимая ошибка <br>(например нарушение защиты памяти)                       | Синхронное                     | Процессор не возвращается к выполнению инструкции                           |

---
##  Traps and system calls

**Ловушки (traps)** - это преднамеренные исключения, возникающие в результате выполнения инструкции. Обработчики ловушек возвращают управление следующей инструкции, подобно обработчикам прерываний.


Основным применением ловушек является предоставление **процедурного интерфейса** между пользовательскими процессами и ядром операционной системы.

Данный процедурный интерфейс называется ***Системным вызовом*** (System call). То есть системный вызов - это механизм взаимодействия между пользовательскими процессами и ядром операционной системы.

Системные вызовы предоставляют интерфейс для выполнения операций, требующих повышенных привилегий, которые недоступны в пользовательском режиме.

![trap handling|500](https://github.com/user-attachments/assets/b8781b91-c3b7-435d-8bb6-e6daf692ba33)


**Системный вызов** с точки зрения пользователя выглядит как обычный вызов функции, но на самом деле его реализация существенно отличается.

**Обычные функции** выполняются в **пользовательском режиме** (user mode). Этот режим ограничивает набор инструкций, которые они могут выполнять, и заставляет их использовать тот же сегмент стека (user stack), что и вызывающая функция.

**Системный вызов**, напротив, выполняется в **режиме ядра** (kernel mode). Этот режим позволяет ему выполнять любые инструкции и использовать стек ядра (kernel stack).


### Linux system calls

Linux предоставляет сотни системных вызовов, которые используются процессами для запроса "услуг" от ядра.

Каждый системный вызов имеет уникальный целочисленный идентификатор, который соответствует смещению в таблице переходов (jump table) в ядре.

`Jump table` - это структура данных в ядре, которая сопоставляет идентификаторы исключений с соответсвующими им обработчиками.

Рассмотрим основные системные вызовы в Linux:

| Системный вызов | Описание                                                                   |
| --------------- | -------------------------------------------------------------------------- |
| `fork()`        | Создает новый процесс, который является копией родительского процесса.     |
| `exec()`        | Заменяет текущий процесс новым процессом, загружая новый исполняемый файл. |
| `wait()`        | Ожидает завершения дочернего процесса.                                     |
| `exit()`        | Завершает выполнение текущего процесса.                                    |
| `open()`        | Открывает файл и возвращает файловый дескриптор.                           |
| `close()`       | Закрывает файловый дескриптор.                                             |
| `read()`        | Читает данные из файлового дескриптора.                                    |
| `write()`       | Записывает данные в файловый дескриптор.                                   |
| `lseek()`       | Изменяет позицию чтения/записи в файловом дескрипторе.                     |
| `stat()`        | Получает информацию о файле или каталоге.                                  |
| `chmod()`       | Изменяет права доступа к файлу.                                            |
| `chown()`       | Изменяет владельца файла.                                                  |
| `kill()`        | Отправляет сигнал процессу.                                                |
| `pipe()`        | Создает канал для межпроцессного взаимодействия.                           |
| `dup()`         | Дублирует файловый дескриптор.                                             |
| `mmap()`        | Отображает файл или устройство в виртуальную память.                       |
| `munmap()`      | Удаляет отображение памяти.                                                |
| `socket()`      | Создает сокет для сетевого взаимодействия.                                 |
| `bind()`        | Привязывает сокет к адресу.                                                |
| `listen()`      | Переводит сокет в режим ожидания подключений.                              |
| `accept()`      | Принимает входящее соединение на сокете.                                   |
| `connect()`     | Устанавливает соединение с сокетом на другом хосте.                        |
| `send()`        | Отправляет данные через сокет.                                             |
| `recv()`        | Получает данные через сокет.                                               |

В языке C функции могут вызывать любой системный вызов напрямую с помощью функции `syscall`, однако на практике это редко необходимо, так как стандартная библиотека C предоставляет набор удобных обёрточных функций для большинства системных вызовов.

Обёрточные функции упаковывают аргументы для системного вызова, обращаются к ядру с помощью соответсвующего номера системного вызова и возвращают статус системного вызова обратно вызывающей функции.

Например реализуем вывод `"hello world"` напрямую с помощью системных вызовов `write` и `exit`:

``` c
int main() {
	write(1, "hello world\n", 13);
	exit(0);
}
```

``` C
.section .data
string:
	.ascii "hello, world\n"
string_end:
	.equ len, string_end - string


.section .text
.globl main
main:
// First, call write(1, "hello, world\n", 13)
	movl $4, %eax // <-- System call number 4
	movl $1, %ebx // <-- stdout has descriptor 1
	movl $string, %ecx // <-- Hello world string
	movl $len, %edx // <-- String length
	int $0x80 // <-- System call code

// Next, call exit(0)
	movl $1, %eax // <-- System call number 0
	movl $0, %ebx // <-- Argument is 0
	int $0x80 // <-- System call code
```

---
## Faults and aborts

`folts` и `aborts` - это два класса синхронных исключений. В отличие от прерываний и ловушек, которые могут возникать как в результате внешних событий, так и преднамеренно, `folts` и `aborts` возникают из-за ошибок в выполении инструкций.

`Faults` - это исключения, которые могут быть исправлены Обработчиками исключений. Обработчик сбоя пытается исправить ошибку, и если это удаётся, выполнение программы продолжается с инструкции, вызвавшей сбой. Если исправление невозможно, процесс завершается.

Примерами `faults` в Linux являются:

- Divide Error (Ошибка деления)
	- возникает при попытке деления на ноль
	- процесс не восстанавливается, а завершается
	
- Page fault (Ошибка страницы)
	- возникает при попытке обращения к странице памяти, которая в данный момент не подгружена в физическую память
	- Обработчик подгружает необходимую страницу с диска в физическую память и перезапускает инструкцию


`Aborts` - это исключения, которые не могут быть восстановлены. Обработчик не пытается восстановить выполнение процесса, а просто завершает его

Примерами `aborts` в Linux являются:

- General protection fault (Общая ошибка защиты)
	- возникает по нескольким причинам, обычно из-за того, что инструкция ссылается на неопределённую область виртуальной памяти или пытается записать данные в сегмент, доступный только для чтения
	- Процесс завершается, зачастую с сообщением "Segmentation fault"

- Machine check
	- возникает в результате фатальной аппаратной ошибки, обнаруженной во время выполнения инструкции.
	- данное исключение не является исправимым, поэтому ядро завершает процесс 


---
## Signals

Сигналы - это асинхронные уведомления, которые могут быть отправлены процессу или группе процессов.

Сигналы уведомляют процесс о том, что в системе произошло событие определённого типа.

Каждый тип сигнала соответствует определённому типу системного события. Например, если процесс делает недопустимый доступ к виртуальной памяти, ядро отправляет ему сигнал `SIGSEGV` с идентификатором 11.

При этом сам процесс может принудительно завершить другой процесс, отправив ему сигнал `SIGKILL` с идентификатором 9.

Передача сигнала целевому процессу происходит в 2 этапа:

- **Отправка сигнала**. Ядро отправляет сигнал целевому процессу, обновляя некоторое состояние в контексте целевого процесса. При этом процесс может отправить сигнал самому себе.

- **Получение сигнала**. Целевой процесс получает сигнал, когда ядро заставляет его реагировать каким-либо образом на доставку сигнала. 


Процесс может реагировать сигнал тремя способами.Либо проигнорировать сигнал, либо завершиться, либо перехватить сигнал, выполнив вызов обработчика сигнала.

Если процесс не готов к обработке сигнала (например он выполняет системный вызов), сигнал становится **ожидающим**. В любой момент времени может быть не более одного ожидающего сигнала определённого типа. Если процесс уже имеет ожидающий сигнал того же типа, новые сигналы этого типа будут отброшены.

