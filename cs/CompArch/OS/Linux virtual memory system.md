Linux поддерживает отдельное виртуальное адресное пространство для каждого процесса.

В Linux виртуальное адресное пространство делится на 2 основные части, которые в свою очередь разделены на различные сегменты виртуальной памяти.


<img src="https://github.com/user-attachments/assets/a21cd5be-1795-4da9-8022-16b2c203354d" alt="Linux_vm" width="500">


## Kernel virtual Memory

данная часть виртуального адресного пространства используется ядром операционной системы

в этой области содержится код и структуры данных, небходимые для работы ядра

Код ядра является общим для всех процессов в системе

---

## Process virtual Memory

Каждый процесс имеет своё собственное виртуальное адресное пространство, которое изолировано от других процессов.

Виртуальное пространство процесса представляет из себя коллекцию *сегментов*

- Сегмент - это непрерывный фрагмент виртуальной памяти, страницы которой связаны между собой по какому-то признаку
	- Каждая существующая виртуальная страница обязательно содержится в каком-то из сегментов.



<img src="https://github.com/user-attachments/assets/de96d5a6-b875-4b56-a055-a17a1682db3f" alt="vm_segment_structs_list" width="700">


- Ядро ОС поддерживает отдельную структуру данных `task_struct` для каждого процесса в системе.
	- Поля данной структуры содержат или указывают на всю информацию, которая необходима ядру для выполнения процесса.
		
- Одно из полей `task_struct` указывает на структуру `mm_struct`, которая характеризует текущее состояние виртуальной памяти.
	- `mm_struct` содержит поле `pgd`, которое указывает на начало таблицы страниц первого уровня иерархии (page global directory).
		- также `mm_struct` содержит поле `mmap`, которое указывает на список [структур](https://litux.nl/mirror/kerneldevelopment/0672327201/ch14lev1sec2.html) `vm_area_structs`, каждая из которых характеризует соответсвующий сегмент виртуального пространства (указатели на начало и конец, флаги, ...)


<img src="https://github.com/user-attachments/assets/2ff5eed9-dcd3-44e6-96f8-6fb95827a95d" alt="page_tables" width="550">

---

В Linux для каждой страницы [физической памяти](https://www.kernel.org/doc/html/v5.2/vm/memory-model.html) ядром  создаётся отдельная [структура](https://litux.nl/mirror/kerneldevelopment/0672327201/ch11lev1sec1.html) `page`, которая хранится в специальной области page cache. Она содержит всю информацию о данной странице физической памяти и имеет отображение с данной страницей через PFN (page frame number)

``` C
// This structure is defined in <linux/mm.h>
struct page {
        page_flags_t flags;
        atomic_t _count;
        atomic_t _mapcount;
        unsigned long private;
        struct address_space* mapping;
        pgoff_t index;
        struct list_head lru;
        void* virtual;
};
```



---

## Page fault exception handling && segfault :)

Когда блок управления памятью (Memory Management Unit, MMU) вызывает page fault при попытке преобразовать некоторый виртуальный адрес **A**, это приводит к передаче управления обработчику ошибок, который является частью ядра операционной системы.

Страничные ошибки могут быть вызваны ошибками в коде или злонамеренно составленными адресами, к которым процессор получает инструкции. 

Например, при обращении к (non-shared) памяти, которая не принадлежит собственному адресному пространству этого процесса, или попытке выполнить инструкцию, которая хочет записать в место, доступное только для чтения.  
  
Если вышеупомянутые условия происходят в пользовательском пространстве, ядро посылает текущему потоку сигнал Segmentation Fault (SIGSEGV). Этот сигнал обычно приводит к завершению потока и процесса, которому он принадлежит.

Если же ядро определило, что ошибка страницы произошла из-за законной операции с действительным виртуальным адресом, обработчик выбирает выполняет классическую обработку `page fault`. (подробно работа обработчика описана [тут](obsidian://open?vault=my_notes&file=cs%2FCompArch%2FVirtual%20memory%20(VM)))


<img src="https://github.com/user-attachments/assets/47ddaafe-6fc8-40f9-87b8-4976e6198abe" alt="page_fault_linux" width="650">


---
## Memory mapping

Memory mapping - это механизм, который позволяет отображать исполняемый файл в виртуальное адресное пространство процесса.

Данный механизм позволяет уменьшить число внешних операций чтения / записи.

Отображение файлов в память позволяет обеспечить доступ к файлам путем прямого помещения их содержимого в адресное пространство процесса.


Многие программы требуют доступа к идентичным копиям динамических read-only библиотек (shared libraries). Сохранение копий этого часто используемого кода для каждого процесса было бы крайне неэффективно.

К счастью, memory mapping предоставляет возможность нескольким процессам использовать общие ресурсы.

Когда объект (например файл иди область памяти) отображается в виртуальную память процесса, он может быть либо *общим* (shared), либо *частным* (private).

---
### Shared object

Если процесс отображает общий объект в область виртуальной памяти, то любые изменения, которые процесс вносит в эту область, будут видны всем другим процессам, которые также отобразили этот объект.

В Unix-подобных системах shared object часто представлены в виде файлов с расширением `.so` (shared object).


<img src="https://github.com/user-attachments/assets/5e3dad1d-2033-4245-9999-b0357daf8247" alt="shared_object" width="400">


Таким образом, когда несколько процессов используют один и тот же shared object, каждый процесс отображает его себе в своё виртуальное адресное пространство. Однако в физической памяти этот объект будет представлен в едином экземпляре.

Страницы памяти, содержащие shared object, помечаются как разделяемые. И помогает это сделать всё та же структура `page`.

---
### Private object

Приватный объект обеспечивает изоляцию данных, так как изменения в этом объекте видны только тому процессу, который его отобразил.

Приватные объекты отображаются в виртуальное пространство процесса, используя механизм copy-on-write (COW).


До момента изменения приватного объекта, он разспологается в физической памяти также, как и shared object. То есть в физической памяти хранится только одна копия приватного объекта.

Когда процесс пытается записать данные в страницу в своей private области, это вызывает защитное исключение (protection fault), так как страница помечена как read-only. Обработчик исключения (fault handler) определяет, что исключение было вызвано попыткой записи в страницу в private copy-on-write области.
    
Обработчик создает новую копию страницы в физической памяти, обновляет запись в таблице страниц, чтобы она указывала на новую копию, и восстанавливает разрешения на запись для этой страницы.

После того как обработчик исключения завершает свою работу, CPU повторно выполняет операцию записи, которая теперь происходит на вновь созданной странице.


<img src="https://github.com/user-attachments/assets/062f52e4-9dfd-491c-b4eb-8471f35d89e0" alt="copy-on-write" width="400">


---
