***Процесс*** — это ключевая сущность любой многозадачной операционной системы, представляющая собой исполняемый объектный код и сопутствующие ему ресурсы:

- **Внутренние данные ядра:** Информация, необходимая операционной системе для управления процессом.
    
- **Состояние процессора:** Значения регистров процессора, актуальные для текущего выполнения процесса.
    
- **Контекст:** Совокупность всех данных, необходимых для возобновления выполнения процесса после прерывания.
    
- **Потоки:** Единицы выполнения внутри процесса, разделяющие его ресурсы.
    
- **Виртуальное пространство:** Адресное пространство, выделенное процессу для хранения данных.


С точки зрения ядра Операционной системы, процесс — это сущность, которой выделяются системные ресурсы, такие как время процессора и память.

Процесс создаётся с помощью системного вызова `fork()`. Данный системный вызов создаёт новый процесс, путём дублирования существующего. Родительский процесс продолжает выполнение, а дочерний начинает выполнение с того же места, где был вызвал `fork()`.

Процесс завершается с помощью системного вызова `exit()`, который освобождает все ресурсы процессора.


В ядре Linux все процессы и потоки называются **задачами** `(tasks)`. Ядро Linux не делает различий между потоками и обычными процессами на уровне управления задачами, так как фактически, потоки являются "легковесными процессами" (`LWP`).

---
## Process descriptor

Ядро операционной системы должно иметь чёткое представление о том, как выполняется каждая задача. Для этого ядру необходимо знать множество параметров и деталей о каждом процессе.

Все эти данные о каждом процессе хранятся в специальной структуре данных, называемой ***дескриптором процесса***.

В Linux эта структура называется `task_struct`. Данный дескриптор процесса содержит множество полей, которые описывают различные параметры и атрибуты задачи.
Большая часть кода ядра, связанного с процессами, работает непосредственно с данной структурой.

![process_descriptor|750](https://github.com/user-attachments/assets/bef8a758-a11c-49bc-9d75-5abc6698cb15)

Каждому процессу ядро присваивает уникальный идентификатор `PID` (Process Identification Value). Ядро хранит `PID` внутри каждого дескриптора процесса. Из-за совместимости с более ранними версиями, значение `PID` по умолчанию ограничено значением `short int`. Максимально значение `PID` важно, так как оно определяет максимальное количество процессов, которые могут существовать одновременно в системе.

Подробно разберём основные поля данной структуры для понимания внутренних механизмов:

``` c
struct task_struct {
	// process identifiers
	pid_t pid;
	pid_t tgid;

	// relationships with other processes 
	struct task_struct* parent;
	struct list_head children;
	struct list_head sibling;

	// process state 
	volatile long state;

	// execution context
	struct thread_info* thread_info;
	struct pt_regs* thread_regs;

	// process memory
	struct mm_struct* mm;
	struct mm_struct* active_mm;

	// file_descriptors
	struct files_struct* files;

	// Signals
	struct signal_struct* signal;
	struct sighand_struct* sighand;

	// Scheduler
	struct sched_entity se;
	struct sched_rt_entity rt;
	struct sched_dl_entity dl;

	// ...other fileds;
}
```


- `pid`, `tgid` - это уникальные идентификаторы. `pid` - идентификатор данного процесса, `tgid` - идентификатор группы процессов

- `parent`, `children`, `sibling` предназначены для хранения информации и связи с родительскими и дочерними процессами.

- `state` - это состояние процесса
	- `TASK_RUNNING` (Исполняемый)
	- `TASK_INTERRUPTIBLE` (Прерываемый)
	- `TASK_UNINTERRUPTIBLE` (Непрерываемый)
	- `__TASK_TRACED` (Отслеживаемый другим процессом)
	- `__TASK_STOPPED` (Остановленный)
	- `TASK_DEAD` (Мёртвый)

- `thread_info`, `thread_regs` - это контекст выполнения процесса. структура `thread_regs` содержит состояние процессора для потока выполнения. В ней хранятся значения, хранимые в регистрах, а также флаги состояния процессора.

- `mm`, `active_mm` - это указатели на структуры, описывающие виртуальную память процесса.

- `files` - это указатель на структуру, содержащую открытые файловые дескрипторы.

- `signal`, `sighand` - это структуры, связанные с обработкой сигналов

- `se`, `rt`, `dl` - это структуры, связанные с планировщиком задач. Они содержат информацию, используемую планировщиком для для определения времени, приоритета задачи и способа планирования задачи.



Все дескрипторы процессов хранятся в специальном циклическом двусвязном списке под названием `task_list`. Каждый узел в этом списке представляет из себя дескриптор процесса, который определяется структурой `task_struct` (`<linux/sched.h>`). 

Несмотря на относительно небольшой размер, данная структура содержит всю необходимую ядру информацию о процессе.



![task_list|470](https://github.com/user-attachments/assets/1b507e46-523d-47e8-aada-3d0aa6859570)


Начиная с версии ядра 2.6, дескриптор процесса создаётся динамически через `slab allocator`. 

Напомним, что `slab allocator` - это аллокатор общего назначения, который оптимизирует процесс выделения и освобождения памяти для часто используемых объектов.

В связи с данным изменением, была введена новая структура `thread_info`, которая находится на вершине стека ядра каждого процесса и хранит контекстную информацию о потоке.

``` C
struct thread_info {
	struct task_struct* task;
	struct exec_domain* exec_domain;
	__u32 flags;
	__u32 status;
	__u32 cpu;
	int preempt_count;
	mm_segment_t addr_limit;
	struct restart_block restart_block;
	void* sysenter_return;
	int uaccess_err;
}
```

- `task` - это указатель на структуру `task_struct`, которая описывает процесс или поток.
- `flags` - это флаги потока, которые описывают состояние потока (прерываемость, вытеснение и другие атрибуты)
- `preempt_count` - это счётчик прерывания.
- `addr_limit` - это ограничение адресного пространства, которое определяет, в каком диапазоне адресов может работать поток (`user_space` / `kernel_space`).
- `cpu` - это идентификатор ядра процессора, на котором выполняется поток.
- `restart_block` - это блок перезапуска, который используется для возобновления выполнения потока после блокировки.

На самом деле реализация и наполнение данной структуры может зависеть от самой операционной системы и её версии, но общий принцип построения является схожим с данным.


---
## The process family Tree

В `Unix` системах, включая `Linux`, существует чётко определённая иерархия процессов. Все процессы организованы в виде дерева, где каждый процесс, кроме начального имеет родительский процесс.

Все процессы в системе являются потомками процесса `init`, который имеет `PID` равный единице. Процесс `init` запускается ядром на последнем шаге процесса загрузки системы.

Для процесса `init` существует статически выделенный дескриптор процесса под названием `init_task`. Данный дескриптор существует на протяжении всего времени работы системы.

`init_task` является отправной точкой для всех процессов в системе. Любой процесс в системе можно отследить до 
`init_task`, проходя по цепочке родительских процессов.


Каждый процесс в системе имеет ровно одного родителя. В то же время, каждый процесс может иметь или не иметь дочерних процессов.

Процессы, которые являются потомками одного и того же родительского процесса, называются `siblings`.



![relationship between processes|530](https://github.com/user-attachments/assets/8a1998ed-6bd3-4b92-9d7c-b7e48f3ba5c3)

Иерархия процессов важна для управления процессами в системе. Например, когда родительский процесс завершается, его дочерние процессы могут быть "усыновлены" процессом 
`init`, чтобы избежать появления "зомби"-процессов.

Иерархия процессов также важна для отправки сигналов. Например, родительский процесс может отправить сигнал всем свои дочерним процессам, используя их `PID`. 


В Linux существуют утилиты, такие как `pstree`, которые позволяют визуализировать иерархию процессов в виде дерева.