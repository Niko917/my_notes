
$O(log_n)$ является одним более эффективных классов сложности.

- Как вычисляется логарифмическая сложность?

	Обычно логарифмическая сложность вычисляется путем подсчета количества раз, которое размер входных данных делится нацело до достижения базового случая. 

	В контексте бинарного поиска, например, каждое деление массива пополам уменьшает количество возможных мест, где может находиться искомый элемент, и таким образом уменьшает пространство поиска. 

	Это деление продолжается до тех пор, пока не останется один элемент или не будет достигнут базовый случай (элемент найден или пространство поиска исчерпано).

---
## Бинарный поиск

```
#include <iostream>
#include <vector>

int binarySearch(const std::vector<int>& arr, int target) {
    int left = 0;
    int right = arr.size() - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] == target) {
            return mid; // элемент найден
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1; // элемент не найден
}

int main() {
    std::vector<int> data = {2, 3, 4, 10, 14, 23, 37, 50};
    int target = 23;
    int result = binarySearch(data, target);

    if (result != -1) {
        std::cout << "Element found at index " << result << std::endl;
    } else {
        std::cout << "Element not found in the array" << std::endl;
    }

    return 0;
}
```

--- 

## Быстрое возведение в степень числа.

```
#include <iostream>

double fastPow(double a, int n) {
    if (n == 0) return 1;
    if (n < 0) {
        n = -n;
        a = 1 / a;
    }
    double result = 1;
    while (n > 0) {
        if (n % 2 == 1) {
            result *= a;
        }
        a *= a;
        n /= 2;
    }
    return result;
}

int main() {
    double a = 2.0;
    int n = 10;
    std::cout << "Power: " << fastPow(a, n) << std::endl;
    return 0;
}
```
---

## Итеративный алгоритм Евклида.
	
```
 int gcd(int a, int b) {
       while (b != 0) {
           int tmp = b;
           b = a % b;
           a = tmp;
       }
       return a;
   }
```
---

## Алгоритм поиска в разреженной таблице

```
   void buildSparseTable(int arr[], int n) {
       for (int i = 0; i < n; i++)
           sparseTable[i][0] = arr[i];

       for (int j = 1; (1 << j) <= n; j++) {
           for (int i = 0; (i + (1 << j) - 1) < n; i++) {
               sparseTable[i][j] = min(sparseTable[i][j-1], sparseTable[i + (1 << (j-1))][j-1]);
           }
       }
   }

   int query(int L, int R) {
       int j = (int)log2(R - L + 1);
       return min(sparseTable[L][j], sparseTable[R - (1 << j) + 1][j]);
   }
```