данная сложность алгоритмов является одной из самых неэффективных на больших входах данных.

обычно за такую сложность работают алгоритмы,связанные с комбинаторными задачами (перестановки и комбинации), а также в теории графов и комбинаторной оптимизации.

---

## Генерация всех наборов перестановок чисел.

``` C++
#include <algorithm>
#include <vector>
#include <iostream>

void print_Permutations(std::vector<int>& nums) {
	do {
		for (int num : nums) {
			std::cout << num <<' ';
		}
		std::cout << '\n';
	}
	while (std::next_permutation(nums.begin(), nums.end()));
}
```

---

## Задача коммивояжера (TSP) с полным перебором.

``` C++
#include <iostream>
#include <vector>
#include <algorithm>

int tspBruteForce(std::vector<std::vector<int>>& graph, int s) {
    std::vector<int> vertices;
    for (int i = 0; i < graph.size(); i++) {
        if (i != s) vertices.push_back(i);
    }

    int min_path = INT_MAX;
    do {
        int current_pathweight = 0;
           
        int k = s;
        for (int i = 0; i < vertices.size(); i++) {
            current_pathweight += graph[k][vertices[i]];
            k = vertices[i];
        }
        current_pathweight += graph[k][s];
           
        min_path = std::min(min_path, current_pathweight);
    } while (std::next_permutation(vertices.begin(), vertices.end()));

    return min_path;
   }

int main() {
    std::vector<std::vector<int>> graph = {{0, 1, 15, 6},
                                              {2, 0, 7, 3},
                                              {9, 6, 0, 12},
                                              {10, 4, 8, 0}};
    int s = 0;
    std::cout << "The cost of the shortest tour is " << tspBruteForce(graph, s);
    return 0;
   }
```

---
## Решение задачи о n-ферзях с полным перебором всех размещений.

``` C++
#include <iostream>
#include <vector>

bool isSafe(int row, int col, std::vector<std::vector<int>>& board) {
    for (int i = 0; i < col; i++)
        if (board[row][i])
            return false;

    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--)
        if (board[i][j])
            return false;

    for (int i = row, j = col; j >= 0 && i < board.size(); i++, j--)
        if (board[i][j])
            return false;

    return true;
   }

void solveNQUtil(int col, std::vector<std::vector<int>>& board, std::vector<std::vector<int>>& solutions) {
    if (col == board.size()) {
        solutions.push_back(board[0]); // Add solution
        return;
       }

    for (int i = 0; i < board.size(); i++) {
        if (isSafe(i, col, board)) {
            board[i][col] = 1;
            solveNQUtil(col + 1, board, solutions);
            board[i][col] = 0; // Backtrack
           }
       }
   }

std::vector<std::vector<int>> solveNQ(int N) {
    std::vector<std::vector<int>> board(N, std::vector<int>(N, 0));
    std::vector<std::vector<int>> solutions;
    solveNQUtil(0, board, solutions);
    return solutions;
   }

int main() {
    int N = 4;
    auto solutions = solveNQ(N);
    std::cout << "One of the solutions for " << N << " Queens is:\n";
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            std::cout << solutions[0][i * N + j] << " ";
           }
        std::cout << std::endl;
       }
    return 0;
   }
```
